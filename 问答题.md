# 问答题
**1.ROS2中的话题和服务有什么区别？实际应用中怎么使用这两种机制并举例**

话题：一般分为发布方和订阅方，发布方持续发布，订阅方持续接收。

服务：一般分为服务方和客户方，运用的场景一般是
发布一次消息并且最终接受一次消息，本质是请求-响应，缺点是无法获取对于物体运动过程的监控

**2.如何理解ros2的tf系统，请从通信机制/数学原理/设计目标作答**

通信机制：通信载体是话题，通过树状坐标系进行变换管理，利用/tf和/tf_static话题广播变换，再利用tf_buffer订阅话题并且缓存

数学原理：利用四元数/旋转矩阵加上平移向量，齐次变换法则的链式乘法

设计目标：为了在不需要所有物体的绝对坐标，仅仅需要相对坐标就可以计算两个物体之间的距离和位置关系。也就是说每个物体只需要发布相对变换，tf系统可以维护完整的变换树，按需要计算任意两个物体之间的距离关系

**3.介绍几种c++常用的关键字，多多益善**

1. 现代c++常用

    * auto：自动类型推导
    * nullptr：空指针
    * override：显示重写
    * constexpr：可以在编译器时求好值，也可以在运行时求值
    * noexcept：无论什么时候保证声明该函数不会出错
    * decltype（auto）：自动类型推导，只返回类型
2. 面向对象
    * virtual：虚函数，多态基础
    * explicit：防止隐式转换
    * public：公有
    * private：私有
    * protected：保护
3. 类型相关
    * using：例如using namespace std或者using IntPtr = int*作为类型别名
    * const：只读，保护对象不被修改
    * static：静态

**4.C++中的智能指针分别用于哪些场景？简述它们的差异与底层机制**

unique_ptr：运用于一般是只被用一次，独占所有权，并且只在一个节点里面，一般与make_unique搭配

shared_ptr:运用于一般是要在多个地方使用，不只在一个节点里面被使用，比如说tf里面的tf_broadcaster，一般与make_shared使用

weak_ptr:解决循环引用

最主要的不同是：unique_ptr不可以被拷贝，只可以被移动，但是shared_ptr可以被拷贝。

需要注意的是shared_ptr每次被释放之后，使用次数减一，而不是一次性释放所有，当最后一个引用被销毁的时候才释放对象。否则其他被拷贝的部分会变成null

相比于new而言，unique_ptr和shared_ptr更加智能，可以自动管理生命周期，避免内存泄漏，避免手动delete

**5.介绍几种最优化算法**

1. 梯度下降算法：

    步骤：先确定一个预测函数，再通过计算写出代价函数，再代价函数图像上选择一个起始点并且进行梯度计算，最后按照学习率前进，不断重复梯度计算和按照学习率前进这两个步骤，直到找到全局最低点

    分类：

        批量梯度下降（BGD）——速度比较慢，但 是算法精准
        随机梯度下降（SGD——速度很快，但是损失精度
        最小批量梯度下降（MBDG）——速度快于批量梯度下降，算法精准度高于随机梯度下降
2. 牛顿法：

    通过计算梯度下降法中的代价函数的导数函数进行梯度下降的趋势判断，可以优化梯度下降法中坡度越缓逼近越慢的问题，计算速度很快，但是计算量太大了

3. 高斯-牛顿法：

    就是一开始将一个不是线性的图像在一块小区域里面利用泰勒公式线性化，然后求解出残差，然后根据残差调整现在状态继续求解直到找到最优解。例如在PNP算法中的运用，投影和实物的关系并不是线性的。这种方法速度很快，但是有很多限制，比如说需要比较好的初值，只适应最小二乘问题等。

4. LM算法：

    本质是在高斯-牛顿法的公式里面加入可以调节的阻尼，从而避免掉高斯牛顿法一些无法使用的情况，使其更加稳定。例如在SOLVEPNP_ITERATIVE里面使用

**6.简单介绍一种 PNP 算法的求解方法及其与其他算法在某些情况下的优势**

PNP算法本质就是知道一个物体的三维坐标点和在照片上的相对应的二维坐标点，然后利用若干组这样的点求解出相机的位置和朝向，但是一般而言可以取逆从而求出物体的位置和朝向。

P3P：利用三对三维坐标点和对应的二维坐标点求出最多四个可能正确的相机位置和朝向，但是这里需要第四对点去验证到底哪个位置和朝向才是正确的。这种方式对于所需要的点要求比较高，但是计算量相对于EPNP而言比较小

另外几种：EPNP，非线性优化

EPNP——把所有对点都进行解算，只需要进行一次计算，对点要求不高，速度很快，计算量比较小，但是可能精度不够，可以用来求初值

非线性优化——算出三维坐标点在计算模型里面推出的相机点和实际点的差距，然后不断调整不断缩小逼近实际点，最小化重投影误差，精度很高

**7.OpenCV 的边缘检测是怎么实现的。**

第一步：进行图片处理

首先将彩图进行灰度处理，再进行高斯模糊处理

第二步：进行边缘检测

进行边缘检测处理cv::Canny

1. 先用高斯滤波处理图片，减少图片中的噪声，防止过多的噪声点被当成边缘被检测

2. 在用sobel算法对垂直方向和水平方向的梯度进行计算幅值，计算方式是sqrt(Gx² + Gy²)

3. 计算梯度方向，计算方式是atan2(Gy, Gx)，指亮度增加最快的方向。梯度方向和边缘方向垂直。注意：只在梯度方向上保留幅值最大的那个像素，抑制其他像素（非极大值抑制）。

4. 利用阈值进行筛选，大于高阈值的一定是边缘点，低于低阈值的一定不是边缘点，处于两者之间的，接近高阈值的可以保留（之后阈值）。

5. 最后输出的是二值化图像，边缘用白色的线连接，其余部分是黑色

**10.请你简述一下这段时间的学习成果，以及后续对 RM 比赛的计划。**

从大一刚开学一直到准备正式成员考核的这一段时间确实是一段非常高强度的学习时光。从最开始对于c语言都不能熟练使用，到后面的逐渐深入c++语言，学习ros2库，opencv库，最优化算法的了解……很多很多在一开始在听宣讲会了解到，并且感觉不可能学会的知识，竟然在这一段时间里面通过积累学习，最终能达到一个入门工程师的水平。我感觉收获满满，十分充实。

在一边听课，学习前辈们给予“圣经”的同时，我通过上手自己敲代码，从跟着课程一行一行复制粘贴式的demo运行，到后面可以慢慢自己设计程序骨架，明白如何设计程序才能便于调试……这些经验也在这一段时间慢慢积累，让我越来越接近成为一个真正可以设计程序，可以将想法付诸于代码的人，我感觉非常不可思议，自己竟然可以坚持到现在。确实学习每一个新的知识的开始都是十分痛苦的，但是在这个过程中，每次程序成功运行的喜悦，也让我一遍又一遍的坚定了自己走下去的想法

当然，如果我有幸成为崇实战队算法组的一名正式成员，我将会将战队任务放在课余事情的首位，来和其他队员一起建设新一个赛季。在刚进入战队初期，我会在巩固自己所掌握的知识的基础上去深入阅读我们自己战队的开源库，并且着手进行代码的复现。首先学习自己战队所运用的想法，在学习了解自己战队的开源之后，学习其他学校强队的代码，开阔自己的思路，获得更多的知识。其次，如果接到具体任务，可以不断提升自己的工程能力和知识，不断学习，能够逐渐在学习的过程中最终达到调试一台真正的机器人的能力，并且能够让大家信任我，交给我一个或者多个兵种的调试任务。另外，在自我学习的过程中，我也会努力维护战队代码环境，整理自己的学习文档，为了巩固所学的知识之外，也为下一届的传承培养做准备。